#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
set -euo pipefail

IMAGE_NAME="agent-container:latest"
CONTAINER_PREFIX="agent"
LABEL="agent-container=true"
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

DEFAULT_MOUNTS=(
    "$HOME/.claude"
    "$HOME/.claude.json"
    "$HOME/.gitconfig"
    "$HOME/.aws"
    "$HOME/.config/gh"
    "$HOME/.config/git"
    "$HOME/.config/NuGet"
    "$HOME/.ssh"
    "$HOME/src"
)

usage() {
    cat <<EOF
Usage: agent [-n <name>] <command> [options]

Commands:
  build                        Build the container image
  start [workdir]              Start a persistent container (workdir defaults to \$PWD)
  exec [cmd...]                Run command in container (default: bash)
  stop                         Stop and remove a persistent container
  list                         List running agent containers
  claude [args...]             Run claude --dangerously-skip-permissions
  copilot [args...]            Run GitHub Copilot CLI

Start options:
  -m, --mount PATH             Mount an additional host directory (repeatable)
  --mounts PATH:PATH:...       Override the default mount list entirely

Ephemeral options:
  --rm                         Auto-remove container on exit (default: keep)

By default, exec/claude/copilot run in ephemeral containers that are
kept after exit so you can retrieve files. Use --rm to auto-remove them.
Use -n/--name to exec into a persistent container started with 'agent start'.

Container name defaults to "agent-<dir>" where <dir> is the basename of the git
repo root, or the current directory if not in a git repo. Override with -n/--name
or AGENT_CONTAINER_NAME.

Environment variables:
  AGENT_CONTAINER_NAME         Override container name
  AGENT_FIREWALL=1             Enable network firewall (opt-in, default off)
  ANTHROPIC_API_KEY            Passed through to container if set
  AGENT_MOUNTS                 Override default mounts (colon-separated paths)
  AGENT_EXTRA_MOUNTS           Append to default mounts (colon-separated paths)

The container always uses the 'vscode' username from the base image.
Host UID/GID are remapped so file ownership is correct on bind mounts.

Default mounts: ~/.claude, ~/.claude.json, ~/.gitconfig, ~/.aws, ~/.config/gh,
                ~/.config/git, ~/.config/NuGet, ~/.ssh, ~/src
The workdir is always mounted automatically.
SSH/GPG agent sockets and Docker socket are forwarded when detected on the host.
EOF
}

find_devcontainer_cli() {
    # The standalone @devcontainers/cli may be shadowed by a VS Code shim.
    # Prefer the npm-installed standalone version.
    local npm_root
    npm_root="$(npm root -g 2>/dev/null)" || true
    if [ -n "$npm_root" ] && [ -x "${npm_root%/lib/node_modules}/bin/devcontainer" ]; then
        echo "${npm_root%/lib/node_modules}/bin/devcontainer"
        return
    fi
    if command -v devcontainer >/dev/null 2>&1; then
        echo "devcontainer"
        return
    fi
    return 1
}

DOTENV_DOCKER_ARGS=()

load_dotenv() {
    local dir="$PWD" files=()
    while [ "$dir" != "/" ]; do
        [ -f "$dir/.env" ] && files+=("$dir/.env")
        dir="$(dirname "$dir")"
    done
    [ ${#files[@]} -eq 0 ] && return

    local -A seen=()
    # Source root-first so nearest .env wins
    for (( i=${#files[@]}-1; i>=0; i-- )); do
        set -a
        # shellcheck disable=SC1090
        source "${files[$i]}"
        set +a
        while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]*(export[[:space:]]+)?([a-zA-Z_][a-zA-Z0-9_]*)[[:space:]]*= ]]; then
                local varname="${BASH_REMATCH[2]}"
                if [ -z "${seen[$varname]+x}" ]; then
                    seen[$varname]=1
                    DOTENV_DOCKER_ARGS+=(-e "$varname")
                fi
            fi
        done < "${files[$i]}"
    done
}

cmd_build() {
    echo "Building ${IMAGE_NAME}..."
    local dc
    if dc=$(find_devcontainer_cli); then
        "$dc" build \
            --workspace-folder "$SCRIPT_DIR" \
            --image-name "$IMAGE_NAME"
    else
        echo "Error: devcontainer CLI not found." >&2
        echo "Install it with: npm install -g @devcontainers/cli" >&2
        exit 1
    fi
    echo "Done. Image: ${IMAGE_NAME}"
}

resolve_name() {
    local name="${AGENT_NAME:-${AGENT_CONTAINER_NAME:-}}"
    if [ -z "$name" ]; then
        local git_root
        git_root="$(git rev-parse --show-toplevel 2>/dev/null)" || true
        name="$(basename "${git_root:-$PWD}")"
    fi
    echo "$name"
}

has_explicit_name() {
    [ -n "${AGENT_NAME:-}" ] || [ -n "${AGENT_CONTAINER_NAME:-}" ]
}

generate_suffix() {
    od -A n -t x1 -N 4 /dev/urandom | tr -d ' \n'
}

# Run a command in a new ephemeral container.
# Used when no explicit container name is given.
run_ephemeral() {
    local name
    name="$(resolve_name)"
    local container="${CONTAINER_PREFIX}-${name}-$(generate_suffix)"
    local workdir="$PWD"

    build_mount_args "$workdir" ""
    build_agent_socket_args

    local env_args=()
    env_args+=(-e "HOST_UID=$(id -u)")
    env_args+=(-e "HOST_GID=$(id -g)")
    env_args+=(-e "HOST_HOME=$HOME")
    env_args+=(-e "AGENT_FIREWALL=${AGENT_FIREWALL:-0}")
    env_args+=(-e "TERM=${TERM:-xterm-256color}")

    if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
        env_args+=(-e "ANTHROPIC_API_KEY")
    fi

    local tty_flags="-i"
    if [ -t 0 ]; then
        tty_flags="-it"
    fi

    local rm_flag=()
    if [ "${AGENT_RM:-0}" = "1" ]; then
        rm_flag=(--rm)
    fi

    docker run $tty_flags \
        --name "$container" \
        --hostname "$container" \
        --label "$LABEL" \
        ${rm_flag[@]+"${rm_flag[@]}"} \
        "${DOTENV_DOCKER_ARGS[@]}" \
        "${env_args[@]}" \
        "${MOUNT_DOCKER_ARGS[@]}" \
        ${AGENT_SOCKET_ARGS[@]+"${AGENT_SOCKET_ARGS[@]}"} \
        --cap-add NET_ADMIN \
        --cap-add NET_RAW \
        -w "$workdir" \
        "$IMAGE_NAME" \
        "$@"
}

# Populate MOUNT_DOCKER_ARGS with -v flags for selective directory mounts.
# Args: workdir, extra_mounts array (passed as remaining args), override_mounts string
build_mount_args() {
    local workdir="$1" override_mounts="$2"
    shift 2
    local -a extra_mounts=("$@")

    MOUNT_DOCKER_ARGS=()
    local -a mounts=()

    # Determine base mount list
    if [ -n "$override_mounts" ]; then
        IFS=':' read -ra mounts <<< "$override_mounts"
    elif [ -n "${AGENT_MOUNTS:-}" ]; then
        IFS=':' read -ra mounts <<< "$AGENT_MOUNTS"
    else
        mounts=("${DEFAULT_MOUNTS[@]}")
    fi

    # Append from AGENT_EXTRA_MOUNTS env var
    if [ -n "${AGENT_EXTRA_MOUNTS:-}" ]; then
        local -a env_extras=()
        IFS=':' read -ra env_extras <<< "$AGENT_EXTRA_MOUNTS"
        mounts+=("${env_extras[@]}")
    fi

    # Append from --mount flags
    mounts+=("${extra_mounts[@]}")

    # Auto-add workdir if not covered by any existing mount
    local workdir_covered=false
    for m in "${mounts[@]}"; do
        if [[ "$workdir" == "$m" || "$workdir" == "$m"/* ]]; then
            workdir_covered=true
            break
        fi
    done
    if ! $workdir_covered; then
        mounts+=("$workdir")
    fi

    # Deduplicate and emit -v flags, skipping non-existent paths
    local -A seen_mounts=()
    for m in "${mounts[@]}"; do
        [ -z "$m" ] && continue
        [ -n "${seen_mounts[$m]+x}" ] && continue
        seen_mounts[$m]=1
        if [ -e "$m" ]; then
            MOUNT_DOCKER_ARGS+=(-v "$m:$m")
        fi
    done
}

# Populate AGENT_SOCKET_ARGS with -v and -e flags for SSH/GPG agent forwarding.
build_agent_socket_args() {
    AGENT_SOCKET_ARGS=()

    # SSH agent forwarding
    if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "$SSH_AUTH_SOCK" ]; then
        AGENT_SOCKET_ARGS+=(-v "$SSH_AUTH_SOCK:$SSH_AUTH_SOCK" -e SSH_AUTH_SOCK)
    fi

    # GPG agent forwarding
    local gpg_sock
    gpg_sock="$(gpgconf --list-dirs agent-socket 2>/dev/null)" || true
    if [ -n "$gpg_sock" ] && [ -S "$gpg_sock" ]; then
        AGENT_SOCKET_ARGS+=(-v "$gpg_sock:$gpg_sock" -e "HOST_GPG_AGENT_SOCK=$gpg_sock")
        # Mount ~/.gnupg for the public keyring (gpg needs it alongside the agent socket)
        if [ -d "$HOME/.gnupg" ]; then
            AGENT_SOCKET_ARGS+=(-v "$HOME/.gnupg:$HOME/.gnupg")
        fi
    fi

    # Docker socket forwarding (docker-outside-of-docker)
    local docker_sock="/var/run/docker.sock"
    if [ -S "$docker_sock" ]; then
        AGENT_SOCKET_ARGS+=(-v "$docker_sock:$docker_sock")
    fi
}

cmd_start() {
    local name
    name="$(resolve_name)" || { usage >&2; exit 1; }

    # Parse start-specific flags
    local -a extra_mounts=()
    local override_mounts=""
    local -a positional=()
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -m|--mount)
                extra_mounts+=("${2:?Error: --mount requires a path}")
                shift 2
                ;;
            --mounts)
                override_mounts="${2:?Error: --mounts requires a colon-separated path list}"
                shift 2
                ;;
            *) positional+=("$1"); shift ;;
        esac
    done

    local workdir="${positional[0]:-$PWD}"
    local container="$CONTAINER_PREFIX-$name"

    # Resolve workdir to absolute path
    workdir="$(cd "$workdir" && pwd)"

    # Check if already running
    if docker ps -q --filter "name=^${container}$" | grep -q .; then
        echo "Container ${container} is already running."
        echo "Use 'agent exec' to connect, or 'agent stop' to stop it."
        return 1
    fi

    # Clean up stopped container with same name
    if docker ps -aq --filter "name=^${container}$" | grep -q .; then
        docker rm "$container" >/dev/null
    fi

    echo "Starting ${container} (workdir: ${workdir})..."

    build_mount_args "$workdir" "$override_mounts" "${extra_mounts[@]+${extra_mounts[@]}}"
    build_agent_socket_args

    local env_args=()
    env_args+=(-e "HOST_UID=$(id -u)")
    env_args+=(-e "HOST_GID=$(id -g)")
    env_args+=(-e "HOST_HOME=$HOME")
    env_args+=(-e "AGENT_FIREWALL=${AGENT_FIREWALL:-0}")

    if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
        env_args+=(-e "ANTHROPIC_API_KEY")
    fi

    docker run -d \
        --name "$container" \
        --hostname "$container" \
        --label "$LABEL" \
        "${DOTENV_DOCKER_ARGS[@]}" \
        "${env_args[@]}" \
        "${MOUNT_DOCKER_ARGS[@]}" \
        ${AGENT_SOCKET_ARGS[@]+"${AGENT_SOCKET_ARGS[@]}"} \
        --cap-add NET_ADMIN \
        --cap-add NET_RAW \
        -w "$workdir" \
        "$IMAGE_NAME"

    echo "Started. Use 'agent exec' or 'agent claude' to connect."
}

cmd_exec() {
    if [ $# -eq 0 ]; then
        set -- bash
    fi

    if ! has_explicit_name; then
        run_ephemeral "$@"
        return
    fi

    local name
    name="$(resolve_name)" || { usage >&2; exit 1; }
    local container="$CONTAINER_PREFIX-$name"

    local tty_flags="-i"
    if [ -t 0 ]; then
        tty_flags="-it"
    fi

    docker exec $tty_flags \
        -u "$(id -u):$(id -g)" \
        -w "$(pwd)" \
        "${DOTENV_DOCKER_ARGS[@]}" \
        -e "TERM=${TERM:-xterm-256color}" \
        "$container" "$@"
}

cmd_stop() {
    local name
    name="$(resolve_name)" || { usage >&2; exit 1; }
    local container="$CONTAINER_PREFIX-$name"

    echo "Stopping ${container}..."
    docker stop "$container" >/dev/null 2>&1 || true
    docker rm "$container" >/dev/null 2>&1 || true
    echo "Stopped."
}

cmd_list() {
    docker ps -a \
        --filter "label=$LABEL" \
        --format 'table {{.Names}}\t{{.Status}}\t{{.RunningFor}}'
}

cmd_claude() {
    if ! has_explicit_name; then
        run_ephemeral claude --dangerously-skip-permissions "$@"
        return
    fi

    local name
    name="$(resolve_name)" || { usage >&2; exit 1; }
    local container="$CONTAINER_PREFIX-$name"

    local tty_flags="-i"
    if [ -t 0 ]; then
        tty_flags="-it"
    fi

    docker exec $tty_flags \
        -u "$(id -u):$(id -g)" \
        -w "$(pwd)" \
        "${DOTENV_DOCKER_ARGS[@]}" \
        -e "TERM=${TERM:-xterm-256color}" \
        "$container" claude --dangerously-skip-permissions "$@"
}

cmd_copilot() {
    if ! has_explicit_name; then
        run_ephemeral copilot --yolo "$@"
        return
    fi

    local name
    name="$(resolve_name)" || { usage >&2; exit 1; }
    local container="$CONTAINER_PREFIX-$name"

    local tty_flags="-i"
    if [ -t 0 ]; then
        tty_flags="-it"
    fi

    docker exec $tty_flags \
        -u "$(id -u):$(id -g)" \
        -w "$(pwd)" \
        "${DOTENV_DOCKER_ARGS[@]}" \
        -e "TERM=${TERM:-xterm-256color}" \
        "$container" copilot --yolo "$@"
}

# --- Main ---

load_dotenv

# Parse global flags before the subcommand
AGENT_NAME=""
AGENT_RM="0"
while [ $# -gt 0 ]; do
    case "$1" in
        -n|--name)
            AGENT_NAME="${2:?Error: -n/--name requires a value}"
            shift 2
            ;;
        --rm)
            AGENT_RM="1"
            shift
            ;;
        -*)
            # Pass through -h/--help and unknown flags to the case below
            break
            ;;
        *)
            break
            ;;
    esac
done

command="${1:-}"
shift || true

case "$command" in
    build)   cmd_build "$@" ;;
    start)   cmd_start "$@" ;;
    exec)    cmd_exec "$@" ;;
    stop)    cmd_stop "$@" ;;
    list)    cmd_list "$@" ;;
    claude)  cmd_claude "$@" ;;
    copilot) cmd_copilot "$@" ;;
    -h|--help|help|"")
        usage
        exit 0
        ;;
    *)
        echo "Unknown command: $command" >&2
        usage >&2
        exit 1
        ;;
esac
